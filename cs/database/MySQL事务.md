---

## 事务

由一系列数据库操作组成的一个完整的逻辑过程,的是满足ACID特性的一组操作,可以通过Commit提交一个事务,也可以使用Rollback进行回滚

1. 原子性(Atomicity): 事务中所有操作要么全部成功,要么全部失败
2. 一致性(Consistency): 事务从一种一致的状态到另一种一致的状态,不会破坏系统的完整性
3. 隔离性(Isolation): 并发事务之间相互影响的程度
4. 持久性(Durability): 事务所有成功的操作对系统的影响是永久存在的

---

## 并发一致性问题

- 脏读: 事务A读取事务B修改后的记录, 之后事务B失败rollback之后事务A读到了错误的数据
- 不可重复读: 事务A读取某条数据之后事务B成功修改了该记录,A再次读取同条记录前后读取不一致
- 幻影读: 事务A根据某种检索条件读取了若干条记录,事务B插入一条记录,A再次相同检索条件读取了若干条记录前后不一致

---

## 锁类型

- 共享锁(读锁, S锁): 事务对数据加共享锁, 事务对数据只可以读取不可以更新, 其他事务只可以加共享锁, 不可以加互斥锁
- 互斥锁(写锁, X锁): 事务对数据加互斥锁, 事务对数据可以读取也可以更新, 其他事务不可以加共享锁, 也不可以加互斥锁
- 可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎),表级锁(MYISAM引擎),页级锁(BDB引擎 )。

---

## 隔离级别

- 未提交读(Uncommit Read): 事务读取时对数据未加锁, 更新时对数据加行级共享锁(我觉得这句话有问题, 因为共享锁是无法修改数据的), 
- 提交读(Commit Read): 事务读取时对数据加行级共享锁, 一旦读取完就释放掉, 更新时对数据加行级排它锁, 直到事务结束, 可以避免脏读
- 可重复读(Repeatable Read): 事务读取时对数据加行级共享锁,  直到事务结束, 更新时对数据加行级排它锁, 直到事务结束,  可以避免可重复读

---

## MVCC(多版本并发控制)

在每条记录后面添加两个字段记录添加的创建时间(创建版本号)和删除时间(删除版本号), 读取记录的时候读取创建时间小于当前, 删除时间大于当前

---

# 索引

## 索引的本质

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。

我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是[顺序查找](http://en.wikipedia.org/wiki/Linear_search)（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如[二分查找](http://en.wikipedia.org/wiki/Binary_search_algorithm)（binary search）、[二叉树查找](http://en.wikipedia.org/wiki/Binary_search_tree)（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于[二叉查找树](http://en.wikipedia.org/wiki/Binary_search_tree)上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

